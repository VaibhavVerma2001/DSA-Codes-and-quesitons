//namespace in c++ ->
// Namespace declarations appear only at global scope.
// Namespace declarations can be nested within another namespace.
// Namespace declarations donâ€™t have access specifiers. (Public or private)
// No need to give semicolon after the closing brace of definition of namespace.
// We can split the definition of namespace over several units.

/*
#include<iostream>
using namespace std ;

int main ()
{
    int value;
    value = 0;
    double value; // Error here
    value = 0.0;
    return 0 ;
}
*/
// Compiler Error:
// 'value' has a previous declaration as 'int value'
// In each scope, a name can only represent one entity. So, there cannot be two variables with the same name in the same scope. Using namespaces, we can create two variables or member functions having the same name.


//therefore above problem can be solved using namespace 
/* ex->1
#include<iostream>
using namespace std ;

namespace myspace // namespace must have global scope
{ 
    int value = 100; // scope in namespace 
}

int value = 200; //global scope

int main()
{
    int value = 300; //scope inside main function 
    cout<<"value inside main is : "<<value<<endl;
    cout<<"value of global is : "<<::value<<endl;
    cout<<"value inside namespace is : "<<myspace::value<<endl;
    return 0;
}
*/


// class and namespaces ->
// we can define class inside namespace or can declare them inside namespace and define outside 
// example 3 
/*
#include<iostream>
using namespace std;

namespace myspace
{
    class greet //defining class inside namespace
    {
        public :
        void display1() //defined inside
        {
            cout<<"hello"<<endl;
        }
        void display2(); //declared inside and defined outside namespace
    };
}
void myspace ::greet:: display2() //define like this
{
    cout<<"how are you";
}
int main ()
{
    myspace::greet obj;
    obj.display1();
    obj.display2();
    return 0;
}
*/

// Extending namespaces (Using same name twice)
// It is also possible to create two namespace blocks having the same name. The second namespace block is nothing but actually the continuation of the first namespace. In simpler words, we can say that both the namespaces are not different but actually the same, which are being defined in parts.
// example 4 
/*
#include<iostream>
using namespace std ;

namespace first
{
   int val1 = 100;
}
namespace first
{
   int val2 = 200;
}

int main ()
{
    cout<<first::val1<<endl;
    cout<<first::val2<<endl;
    return 0;
}
*/

// Unnamed Namespaces
// They are directly usable in the same program and are used for declaring unique identifiers.
// In unnamed namespaces, name of the namespace in not mentioned in the declaration of namespace.
// The name of the namespace is uniquely generated by the compiler.
// The unnamed namespaces you have created will only be accessible within the file you created it in.
// Unnamed namespaces are the replacement for the static declaration of variables.
//ex -> 5
/*
#include<iostream>
using namespace std ;

namespace 
{
    int val=100;
    void fun()
    {
        cout<<"value is : "<<val;
    }
}
int main ()
{
    fun();
    return 0 ;
}
*/

//if we use using keyword then we dont have to write namespace_name :: , before using identifiers , like we dont write std::cout after writting using namespace std
/*
//ex-> 6
#include<iostream>
using namespace std ;
namespace myspace
{
    int value =10;
}
//use using keyword after defining namespace , otherwise it will give error
using namespace myspace; // using keyword
int main ()
{
    cout<<value; //no need to write as myspace::value
    return 0 ;
}
*/

// Nested Namespaces
// In C++, namespaces can also be nested i.e., one namespace inside another. The resolution of namespace variables is hierarchical.
//example ->7
/*
#include<iostream>
using namespace std;

namespace first
{
    int val1=10;
    namespace second
    {
        int val2=20;
        namespace third
        {
            int val3=30;
        }
    }
}
int main()
{
    cout<<first::val1<<endl;
    cout<<first::second::val2<<endl;
    cout<<first::second::third::val3<<endl;
    return 0;
}
*/

// Namespace Aliasing
// In C++, you can use an alias name for your namespace name, for ease of use. Existing namespaces can be aliased with new names, with the following syntax:
// namespace new_name = current_name;
//ex->8
#include <iostream>
namespace name1 
{
    namespace name2 
    {
         namespace name3 
         {
             int var = 42;
         }
    }
}
// Aliasing 
namespace alias = name1::name2::name3;
int main()
{
    std::cout << alias::var << '\n';
    return 0;
}